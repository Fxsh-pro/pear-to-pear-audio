<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Voice Call</title>
</head>
<body>
<h2>WebRTC Voice Call</h2>

<!-- Room Code Input -->
<label for="roomCode">Enter Room Code:</label>
<input type="text" id="roomCode" placeholder="Enter a room code"><br><br>

<button id="startCall">Start Call</button>
<button id="muteButton" disabled>Mute</button>
<button id="endCallButton" disabled>End Call</button>

<!-- Remote audio streams for all participants -->
<div id="remoteAudioContainer"></div>

<script>
    const startCallButton = document.getElementById('startCall');
    const muteButton = document.getElementById('muteButton');
    const endCallButton = document.getElementById('endCallButton');
    const roomCodeInput = document.getElementById('roomCode');
    const remoteAudioContainer = document.getElementById('remoteAudioContainer');

    let localStream;
    let peerConnections = {};  // Store peer connections by roomCode
    let signalingSocket;
    let isCallInProgress = false;
    let isMuted = false;

    const signalingServerUrl = 'ws://192.168.1.31:8080/signal';
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
        ]
    };

    // Setup WebSocket signaling and handle connection to a room
    function setupSignaling(roomCode) {
        signalingSocket = new WebSocket(signalingServerUrl + `?roomCode=${roomCode}`);
        console.log(`Connecting to signaling server with roomCode: ${roomCode}`);

        signalingSocket.onopen = () => {
            console.log("WebSocket is connected.");
            // Start the call only after WebSocket is connected
            startCall();
        };

        signalingSocket.onmessage = async (message) => {
            const data = JSON.parse(message.data);
            console.log("Received message from server:", data);

            const roomCode = data.peerId || roomCodeInput.value;  // Ensure the correct roomCode is used
            console.log("Using roomCode: " + roomCode);

            if (data.sdp) {
                console.log("Received SDP:", data.sdp);
                await peerConnections[roomCode].setRemoteDescription(new RTCSessionDescription(data.sdp));

                if (data.sdp.type === 'offer') {
                    console.log("Creating answer to the offer.");
                    const answer = await peerConnections[roomCode].createAnswer();
                    await peerConnections[roomCode].setLocalDescription(answer);
                    signalingSocket.send(JSON.stringify({
                        sdp: peerConnections[roomCode].localDescription,
                        peerId: roomCode
                    }));
                    console.log("Sent answer to the signaling server.");
                }
            } else if (data.candidate) {
                console.log("Received ICE candidate:", data.candidate);
                await peerConnections[roomCode].addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log("Added ICE candidate to peer connection.");
            }
        };
    }

    async function startCall() {
        if (isCallInProgress) {
            console.log("Call is already in progress.");
            return;
        }

        isCallInProgress = true;
        startCallButton.disabled = true;
        muteButton.disabled = false;
        endCallButton.disabled = false;
        console.log("Call started, buttons updated.");

        try {
            // Get audio stream from the microphone
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            console.log("Local media stream obtained.");

            // Add local stream to the call
            localStream.getTracks().forEach(track => {
                localStream.addTrack(track);
            });
            console.log("Local media tracks added.");

            const roomCode = roomCodeInput.value;
            if (!roomCode) {
                alert("Please enter a room code.");
                return;
            }
            console.log("Using room code:", roomCode);

            // Create peer connection for the room
            peerConnections[roomCode] = new RTCPeerConnection(configuration);
            console.log("Created new RTCPeerConnection for room:", roomCode);

            // Add the local audio stream to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnections[roomCode].addTrack(track, localStream);
            });
            console.log("Added local audio tracks to the peer connection.");

            // Set up ICE candidate handling
            peerConnections[roomCode].onicecandidate = (event) => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({
                        candidate: event.candidate,
                        peerId: roomCode
                    }));
                    console.log("Sent ICE candidate to signaling server:", event.candidate);
                }
            };

            // Handle remote audio stream for other participants
            peerConnections[roomCode].ontrack = (event) => {
                const remoteStream = event.streams[0];
                console.log("Received remote stream from another participant.");

                const remoteAudio = document.createElement('audio');
                remoteAudio.controls = true;
                remoteAudio.autoplay = true;
                remoteAudio.srcObject = remoteStream;
                remoteAudioContainer.appendChild(remoteAudio);
                console.log("Added remote audio element to the container.");
            };

            // Create SDP offer and send to the server
            console.log("Creating SDP offer.");
            const offer = await peerConnections[roomCode].createOffer();
            await peerConnections[roomCode].setLocalDescription(offer);
            signalingSocket.send(JSON.stringify({
                sdp: peerConnections[roomCode].localDescription,
                peerId: roomCode
            }));
            console.log("Sent SDP offer to the signaling server.");
        } catch (error) {
            console.error("Error starting the call:", error);
        }
    }

    // Function to mute/unmute audio
    function toggleMute() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !track.enabled; // Toggle the audio track
            });

            isMuted = !isMuted;
            muteButton.textContent = isMuted ? 'Unmute' : 'Mute'; // Update button text
            console.log("Mute toggled:", isMuted);
        }
    }

    // Function to end the call
    function endCall() {
        const roomCode = roomCodeInput.value;
        console.log("Ending the call for room:", roomCode);

        if (peerConnections[roomCode]) {
            peerConnections[roomCode].close(); // Close the peer connection for the room
            peerConnections[roomCode] = null;
            console.log("Closed peer connection for room:", roomCode);
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop()); // Stop all tracks (microphone)
            localStream = null;
            console.log("Stopped local media tracks.");
        }

        if (signalingSocket) {
            signalingSocket.close(); // Close WebSocket connection
            signalingSocket = null;
            console.log("Closed signaling WebSocket.");
        }

        isCallInProgress = false;
        muteButton.disabled = true;
        endCallButton.disabled = true;
        startCallButton.disabled = false; // Enable the start call button again
        console.log("Call ended, buttons reset.");
        remoteAudioContainer.innerHTML = ''; // Clear the remote audio container
        console.log("Cleared remote audio container.");
    }

    // Handle start call button click
    startCallButton.addEventListener('click', () => {
        const roomCode = roomCodeInput.value;
        console.log("Start call button clicked, room code:", roomCode);

        if (!roomCode) {
            alert("Please enter a room code.");
            return;
        }
        if (!isCallInProgress) {
            setupSignaling(roomCode); // Initialize WebSocket connection with the room code
        }
    });

    muteButton.addEventListener('click', toggleMute); // Mute button event listener
    endCallButton.addEventListener('click', endCall); // End call button event listener
</script>
</body>
</html>
