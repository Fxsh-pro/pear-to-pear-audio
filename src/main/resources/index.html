<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Voice Call</title>
</head>
<body>
<h2>WebRTC Voice Call</h2>
<label for="roomCode">Enter Room Code:</label>
<input type="text" id="roomCode" placeholder="Enter code"><br><br>
<button id="startCall">Start Call</button>
<button id="muteButton" disabled>Mute</button>
<button id="endCallButton" disabled>End Call</button> <!-- End Call Button -->
<audio id="remoteAudio" controls autoplay></audio>

<script>
    const startCallButton = document.getElementById('startCall');
    const muteButton = document.getElementById('muteButton');
    const endCallButton = document.getElementById('endCallButton');
    const remoteAudio = document.getElementById('remoteAudio');
    const roomCodeInput = document.getElementById('roomCode'); // Room Code input

    let localStream;
    let peerConnection;
    let signalingSocket;
    let isCallInProgress = false;
    let isMuted = false;
    let roomCode; // Variable to hold the room code

    // const signalingServerUrl = 'ws://51.250.76.218:8080/signal';
    const signalingServerUrl = 'ws://127.0.0.1:8080/signal';
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
        ]
    };

    // Setup WebSocket signaling
    function setupSignaling(roomCode) {
        signalingSocket = new WebSocket(signalingServerUrl + `?roomCode=${roomCode}`);

        signalingSocket.onmessage = async (message) => {
            const data = JSON.parse(message.data);

            if (data.sdp) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                if (data.sdp.type === 'offer') {
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    signalingSocket.send(JSON.stringify({ sdp: peerConnection.localDescription }));
                }
            } else if (data.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        };
    }

    async function startCall() {
        if (isCallInProgress) {
            console.log("Call is already in progress.");
            return;
        }

        // Get room code entered by the user
        roomCode = roomCodeInput.value;
        if (!roomCode) {
            alert("Please enter a room code.");
            return;
        }

        isCallInProgress = true;
        startCallButton.disabled = true;
        muteButton.disabled = false;
        endCallButton.disabled = false;

        try {
            // Get audio stream from the microphone
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

            // Create RTCPeerConnection
            peerConnection = new RTCPeerConnection(configuration);

            // Add the local audio stream to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Set up ICE candidate handling
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({ candidate: event.candidate }));
                }
            };

            // Handle remote audio stream
            peerConnection.ontrack = (event) => {
                remoteAudio.srcObject = event.streams[0];
            };

            // Create an SDP offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            setupSignaling(roomCode);  // Initialize signaling with the room code
            signalingSocket.send(JSON.stringify({ sdp: peerConnection.localDescription }));
        } catch (error) {
            console.error("Error starting the call:", error);
        }
    }

    function toggleMute() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !track.enabled;
            });

            isMuted = !isMuted;
            muteButton.textContent = isMuted ? 'Unmute' : 'Mute';
        }
    }

    function endCall() {
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        if (signalingSocket) {
            signalingSocket.close();
            signalingSocket = null;
        }

        isCallInProgress = false;
        muteButton.disabled = true;
        endCallButton.disabled = true;
        startCallButton.disabled = false;
        remoteAudio.srcObject = null;
    }

    startCallButton.addEventListener('click', startCall);
    muteButton.addEventListener('click', toggleMute);
    endCallButton.addEventListener('click', endCall);
</script>
</body>
</html>
