<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Voice Call</title>
</head>
<body>
<h2>WebRTC Voice Call</h2>
<button id="startCall">Start Call</button>
<button id="muteButton" disabled>Mute</button>
<button id="endCallButton" disabled>End Call</button> <!-- End Call Button -->
<audio id="remoteAudio" controls autoplay></audio>

<script>
    const startCallButton = document.getElementById('startCall');
    const muteButton = document.getElementById('muteButton');
    const endCallButton = document.getElementById('endCallButton'); // End Call Button reference
    const remoteAudio = document.getElementById('remoteAudio');

    let localStream;
    let peerConnection;
    let signalingSocket;
    let isCallInProgress = false;
    let isMuted = false;

    const signalingServerUrl = 'ws://192.168.1.16:8080/signal'; // Adjust as necessary
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
        ]
    };

    // Setup WebSocket signaling
    function setupSignaling() {
        signalingSocket = new WebSocket(signalingServerUrl);

        signalingSocket.onmessage = async (message) => {
            const data = JSON.parse(message.data);

            if (data.sdp) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                if (data.sdp.type === 'offer') {
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    signalingSocket.send(JSON.stringify({ sdp: peerConnection.localDescription }));
                }
            } else if (data.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        };
    }

    async function startCall() {
        if (isCallInProgress) {
            console.log("Call is already in progress.");
            return;
        }

        isCallInProgress = true;
        startCallButton.disabled = true;
        muteButton.disabled = false; // Enable the mute button once the call starts
        endCallButton.disabled = false; // Enable the end call button

        try {
            // Get audio stream from the microphone
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

            // Create RTCPeerConnection
            peerConnection = new RTCPeerConnection(configuration);

            // Add the local audio stream to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Set up ICE candidate handling
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({ candidate: event.candidate }));
                }
            };

            // Handle remote audio stream
            peerConnection.ontrack = (event) => {
                remoteAudio.srcObject = event.streams[0];
            };

            // Create an SDP offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            signalingSocket.send(JSON.stringify({ sdp: peerConnection.localDescription }));
        } catch (error) {
            console.error("Error starting the call:", error);
        }
    }

    // Function to mute/unmute audio
    function toggleMute() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !track.enabled; // Toggle the audio track
            });

            isMuted = !isMuted;
            muteButton.textContent = isMuted ? 'Unmute' : 'Mute'; // Update button text
        }
    }

    // Function to end the call
    function endCall() {
        if (peerConnection) {
            peerConnection.close(); // Close the RTCPeerConnection
            peerConnection = null;
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop()); // Stop all tracks (microphone)
            localStream = null;
        }

        if (signalingSocket) {
            signalingSocket.close(); // Close WebSocket connection
            signalingSocket = null;
        }

        isCallInProgress = false;
        muteButton.disabled = true;
        endCallButton.disabled = true;
        startCallButton.disabled = false; // Enable the start call button again
        remoteAudio.srcObject = null; // Stop playing the remote audio
    }

    startCallButton.addEventListener('click', () => {
        if (!isCallInProgress) {
            setupSignaling();
            startCall();
        }
    });

    muteButton.addEventListener('click', toggleMute); // Add event listener for mute button
    endCallButton.addEventListener('click', endCall); // Add event listener for end call button
</script>
</body>
</html>
