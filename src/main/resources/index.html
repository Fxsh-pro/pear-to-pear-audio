<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Voice Call</title>
</head>
<body>
<h2>WebRTC Voice Call</h2>

<!-- Room Code Input -->
<label for="roomCode">Enter Room Code:</label>
<input type="text" id="roomCode" placeholder="Enter a room code"><br><br>

<button id="startCall">Start Call</button>
<button id="muteButton" disabled>Mute</button>
<button id="endCallButton" disabled>End Call</button>

<!-- Container for remote audio -->
<div id="remoteAudioContainer"></div>

<script>
    const startCallButton = document.getElementById('startCall');
    const muteButton = document.getElementById('muteButton');
    const endCallButton = document.getElementById('endCallButton');
    const remoteAudioContainer = document.getElementById('remoteAudioContainer');
    const roomCodeInput = document.getElementById('roomCode');

    let localStream;
    let peerConnections = {}; // store peer connections for each remote peer
    let signalingSocket;
    let isCallInProgress = false;
    let isMuted = false;
    let localPeerId; // New variable to store the local peerId

    const signalingServerUrl = 'ws://192.168.1.31:8080/signal';
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
        ]
    };

    // Setup WebSocket signaling and handle connection to a room
    function setupSignaling(roomCode) {
        signalingSocket = new WebSocket(signalingServerUrl + `?roomCode=${roomCode}`);

        signalingSocket.onopen = () => {
            console.log("WebSocket is connected.");
            // Start the call only after WebSocket is connected
            startCall();
        };

        signalingSocket.onmessage = async (message) => {
            const data = JSON.parse(message.data);
            const peerId = data.peerId;

            if (!peerId) {
                console.error("No peerId in message");
                return;
            }

            if (data.sdp) {
                console.log("Received SDP from peer:", peerId);
                let peerConnection = peerConnections[peerId];
                if (!peerConnection) {
                    console.log("No peer connection found for peerId:", peerId, "Creating a new peer connection...");
                    peerConnection = new RTCPeerConnection(configuration);
                    peerConnections[peerId] = peerConnection;  // Store it
                }

                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                if (data.sdp.type === 'offer') {
                    console.log("offer received from peer:", peerId);
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    signalingSocket.send(JSON.stringify({ sdp: peerConnection.localDescription, peerId: peerId }));
                }
            } else if (data.candidate) {
                console.log("Received ICE candidate from peer:", peerId);
                let peerConnection = peerConnections[peerId];
                if (!peerConnection) {
                    console.error("No peer connection found for peerId:", peerId);
                    return;
                }
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
        };
    }

    async function startCall() {
        if (isCallInProgress) {
            console.log("Call is already in progress.");
            return;
        }

        isCallInProgress = true;
        startCallButton.disabled = true;
        muteButton.disabled = false;
        endCallButton.disabled = false;

        try {
            // Get audio stream from the microphone
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

            // Generate a unique peerId for this user
            localPeerId = Math.random().toString(36).substring(2);

            // Create a new peer connection for this user
            const peerConnection = new RTCPeerConnection(configuration);

            // Add the local audio stream to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Set up ICE candidate handling
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({
                        candidate: event.candidate,
                        peerId: localPeerId
                    }));
                }
            };

            // Handle remote audio stream
            peerConnection.ontrack = (event) => {
                const remoteAudioElement = document.createElement('audio');
                remoteAudioElement.controls = true;
                remoteAudioElement.autoplay = true;
                remoteAudioElement.srcObject = event.streams[0];
                remoteAudioContainer.appendChild(remoteAudioElement);
            };

            // Store peer connection
            peerConnections[localPeerId] = peerConnection;

            // Create an SDP offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            signalingSocket.send(JSON.stringify({
                sdp: peerConnection.localDescription,
                peerId: localPeerId
            }));
        } catch (error) {
            console.error("Error starting the call:", error);
        }
    }

    // Function to mute/unmute audio
    function toggleMute() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !track.enabled; // Toggle the audio track
            });

            isMuted = !isMuted;
            muteButton.textContent = isMuted ? 'Unmute' : 'Mute'; // Update button text
        }
    }

    // Function to end the call
    function endCall() {
        if (Object.keys(peerConnections).length > 0) {
            Object.values(peerConnections).forEach(pc => {
                pc.close();
            });
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop()); // Stop all tracks (microphone)
            localStream = null;
        }

        if (signalingSocket) {
            signalingSocket.close(); // Close WebSocket connection
            signalingSocket = null;
        }

        isCallInProgress = false;
        muteButton.disabled = true;
        endCallButton.disabled = true;
        startCallButton.disabled = false; // Enable the start call button again
        remoteAudioContainer.innerHTML = ''; // Clear all remote audio streams
    }

    // Handle start call button click
    startCallButton.addEventListener('click', () => {
        const roomCode = roomCodeInput.value;
        if (!roomCode) {
            alert("Please enter a room code.");
            return;
        }
        if (!isCallInProgress) {
            setupSignaling(roomCode); // Initialize WebSocket connection with the room code
        }
    });

    muteButton.addEventListener('click', toggleMute); // Mute button event listener
    endCallButton.addEventListener('click', endCall); // End call button event listener
</script>
</body>
</html>
